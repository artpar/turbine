// ═══════════════════════════════════════════════════════════════════════════
// TURBINE - React Frontend Adapter
// ═══════════════════════════════════════════════════════════════════════════
// Generates React/Vite frontend code from spec

import { FrontendAdapter, GeneratedCode, CodeGap, adapterRegistry } from './base.js'
import { Entity, TurbineSpec, getEntityFields, Field, fieldTypeToTS } from '../spec-parser.js'

export class ReactAdapter implements FrontendAdapter {
  name = 'react'

  getDependencies(): Record<string, string> {
    return {
      react: '^18.2.0',
      'react-dom': '^18.2.0',
      'react-router-dom': '^6.21.0',
      '@tanstack/react-query': '^5.17.0',
      'react-hook-form': '^7.49.0',
      '@hookform/resolvers': '^3.3.0',
      zod: '^3.22.0',
      clsx: '^2.1.0',
    }
  }

  getDevDependencies(): Record<string, string> {
    return {
      '@types/react': '^18.2.0',
      '@types/react-dom': '^18.2.0',
      '@vitejs/plugin-react': '^4.2.0',
      vite: '^5.0.0',
      typescript: '^5.3.0',
    }
  }

  generateEntityList(entity: Entity): GeneratedCode {
    const fields = getEntityFields(entity)
    const name = entity.name
    const camelName = name.charAt(0).toLowerCase() + name.slice(1)
    const plural = entity.plural ?? name + 's'

    const tableHeaders = fields
      .filter((f) => !['id', 'createdAt', 'updatedAt', 'deletedAt'].includes(f.name))
      .slice(0, 5)
      .map((f) => `          <th className="px-4 py-2 text-left">${this.toTitleCase(f.name)}</th>`)
      .join('\n')

    const tableCells = fields
      .filter((f) => !['id', 'createdAt', 'updatedAt', 'deletedAt'].includes(f.name))
      .slice(0, 5)
      .map((f) => `          <td className="px-4 py-2">{item.${f.name}${f.type === 'date' || f.type === 'datetime' ? ' && new Date(item.' + f.name + ').toLocaleDateString()' : ''}}</td>`)
      .join('\n')

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// ${name} List Component
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { useState } from 'react'
import { Link, useSearchParams } from 'react-router-dom'
import { use${name}List } from '../hooks/use${name}'
import { Pagination } from '../components/Pagination'
import { SearchInput } from '../components/SearchInput'

export function ${name}List() {
  const [searchParams, setSearchParams] = useSearchParams()
  const page = parseInt(searchParams.get('page') ?? '1', 10)
  const search = searchParams.get('search') ?? ''

  const { data, isLoading, error } = use${name}List({ page, search })

  if (isLoading) return <div className="p-4">Loading...</div>
  if (error) return <div className="p-4 text-red-500">Error: {error.message}</div>

  return (
    <div className="p-4">
      <div className="flex justify-between items-center mb-4">
        <h1 className="text-2xl font-bold">${plural}</h1>
        <Link
          to="/${plural.toLowerCase()}/new"
          className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
        >
          Add ${name}
        </Link>
      </div>

      <SearchInput
        value={search}
        onChange={(value) => setSearchParams({ search: value, page: '1' })}
        placeholder="Search ${plural.toLowerCase()}..."
      />

      <div className="overflow-x-auto mt-4">
        <table className="min-w-full bg-white border">
          <thead className="bg-gray-100">
            <tr>
${tableHeaders}
              <th className="px-4 py-2 text-left">Actions</th>
            </tr>
          </thead>
          <tbody>
            {data?.data.map((item) => (
              <tr key={item.id} className="border-t hover:bg-gray-50">
${tableCells}
                <td className="px-4 py-2">
                  <Link
                    to={\`/${plural.toLowerCase()}/\${item.id}\`}
                    className="text-blue-500 hover:underline mr-2"
                  >
                    View
                  </Link>
                  <Link
                    to={\`/${plural.toLowerCase()}/\${item.id}/edit\`}
                    className="text-green-500 hover:underline"
                  >
                    Edit
                  </Link>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {data && (
        <Pagination
          currentPage={data.meta.page}
          totalPages={data.meta.totalPages}
          onPageChange={(p) => setSearchParams({ page: String(p), search })}
        />
      )}
    </div>
  )
}

export default ${name}List
`

    return {
      path: `src/pages/${name}List.tsx`,
      content,
    }
  }

  generateEntityForm(entity: Entity): GeneratedCode {
    const fields = getEntityFields(entity)
    const name = entity.name
    const camelName = name.charAt(0).toLowerCase() + name.slice(1)
    const plural = entity.plural ?? name + 's'
    const gaps: CodeGap[] = []

    const formFields = fields
      .filter((f) => !['id', 'createdAt', 'updatedAt', 'deletedAt'].includes(f.name))
      .map((f) => this.generateFormField(f))
      .join('\n\n')

    const zodFields = fields
      .filter((f) => !['id', 'createdAt', 'updatedAt', 'deletedAt'].includes(f.name))
      .map((f) => `  ${f.name}: ${this.fieldToZodClient(f)},`)
      .join('\n')

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// ${name} Form Component
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useNavigate, useParams } from 'react-router-dom'
import { use${name}, useCreate${name}, useUpdate${name} } from '../hooks/use${name}'

const ${camelName}Schema = z.object({
${zodFields}
})

type ${name}FormData = z.infer<typeof ${camelName}Schema>

interface ${name}FormProps {
  mode: 'create' | 'edit'
}

export function ${name}Form({ mode }: ${name}FormProps) {
  const navigate = useNavigate()
  const { id } = useParams<{ id: string }>()

  const { data: existing } = use${name}(id, { enabled: mode === 'edit' })
  const createMutation = useCreate${name}()
  const updateMutation = useUpdate${name}()

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<${name}FormData>({
    resolver: zodResolver(${camelName}Schema),
    defaultValues: existing ?? undefined,
  })

  const onSubmit = async (data: ${name}FormData) => {
    try {
      if (mode === 'create') {
        await createMutation.mutateAsync(data)
      } else if (id) {
        await updateMutation.mutateAsync({ id, data })
      }
      navigate('/${plural.toLowerCase()}')
    } catch (error) {
      console.error('Form submission error:', error)
    }
  }

  return (
    <div className="p-4 max-w-2xl mx-auto">
      <h1 className="text-2xl font-bold mb-4">
        {mode === 'create' ? 'Create' : 'Edit'} ${name}
      </h1>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
${formFields}

        <div className="flex gap-4">
          <button
            type="submit"
            disabled={isSubmitting}
            className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:opacity-50"
          >
            {isSubmitting ? 'Saving...' : 'Save'}
          </button>
          <button
            type="button"
            onClick={() => navigate('/${plural.toLowerCase()}')}
            className="bg-gray-300 px-4 py-2 rounded hover:bg-gray-400"
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  )
}

export default ${name}Form
`

    return {
      path: `src/pages/${name}Form.tsx`,
      content,
      gaps,
    }
  }

  private generateFormField(field: Field): string {
    const label = this.toTitleCase(field.name)
    const required = field.validation?.required ? ' *' : ''

    switch (field.type) {
      case 'text':
        return `        <div>
          <label className="block text-sm font-medium mb-1">${label}${required}</label>
          <textarea
            {...register('${field.name}')}
            className="w-full border rounded px-3 py-2"
            rows={4}
          />
          {errors.${field.name} && (
            <p className="text-red-500 text-sm mt-1">{errors.${field.name}.message}</p>
          )}
        </div>`

      case 'boolean':
        return `        <div className="flex items-center gap-2">
          <input
            type="checkbox"
            {...register('${field.name}')}
            className="rounded"
          />
          <label className="text-sm font-medium">${label}</label>
        </div>`

      case 'enum':
        const options = field.enumValues?.map((v) => `            <option value="${v}">${this.toTitleCase(v)}</option>`).join('\n') ?? ''
        return `        <div>
          <label className="block text-sm font-medium mb-1">${label}${required}</label>
          <select
            {...register('${field.name}')}
            className="w-full border rounded px-3 py-2"
          >
            <option value="">Select ${label}</option>
${options}
          </select>
          {errors.${field.name} && (
            <p className="text-red-500 text-sm mt-1">{errors.${field.name}.message}</p>
          )}
        </div>`

      case 'number':
      case 'integer':
        return `        <div>
          <label className="block text-sm font-medium mb-1">${label}${required}</label>
          <input
            type="number"
            {...register('${field.name}', { valueAsNumber: true })}
            className="w-full border rounded px-3 py-2"
          />
          {errors.${field.name} && (
            <p className="text-red-500 text-sm mt-1">{errors.${field.name}.message}</p>
          )}
        </div>`

      case 'date':
      case 'datetime':
        return `        <div>
          <label className="block text-sm font-medium mb-1">${label}${required}</label>
          <input
            type="${field.type === 'datetime' ? 'datetime-local' : 'date'}"
            {...register('${field.name}')}
            className="w-full border rounded px-3 py-2"
          />
          {errors.${field.name} && (
            <p className="text-red-500 text-sm mt-1">{errors.${field.name}.message}</p>
          )}
        </div>`

      default:
        return `        <div>
          <label className="block text-sm font-medium mb-1">${label}${required}</label>
          <input
            type="${field.type === 'email' ? 'email' : field.type === 'url' ? 'url' : 'text'}"
            {...register('${field.name}')}
            className="w-full border rounded px-3 py-2"
          />
          {errors.${field.name} && (
            <p className="text-red-500 text-sm mt-1">{errors.${field.name}.message}</p>
          )}
        </div>`
    }
  }

  private fieldToZodClient(field: Field): string {
    let schema: string

    switch (field.type) {
      case 'string':
      case 'text':
        schema = 'z.string()'
        break
      case 'email':
        schema = 'z.string().email()'
        break
      case 'url':
        schema = 'z.string().url()'
        break
      case 'number':
        schema = 'z.number()'
        break
      case 'integer':
        schema = 'z.number().int()'
        break
      case 'boolean':
        schema = 'z.boolean()'
        break
      case 'date':
      case 'datetime':
        schema = 'z.string()'
        break
      case 'enum':
        schema = `z.enum([${field.enumValues?.map((v) => `'${v}'`).join(', ') ?? ''}])`
        break
      default:
        schema = 'z.string()'
    }

    if (!field.validation?.required) {
      schema += '.optional()'
    }

    return schema
  }

  generateEntityDetail(entity: Entity): GeneratedCode {
    const fields = getEntityFields(entity)
    const name = entity.name
    const plural = entity.plural ?? name + 's'

    const fieldDisplay = fields
      .filter((f) => f.name !== 'id')
      .map((f) => `          <div>
            <dt className="text-sm text-gray-500">${this.toTitleCase(f.name)}</dt>
            <dd className="text-lg">{data.${f.name}${f.type === 'date' || f.type === 'datetime' ? ' && new Date(data.' + f.name + ').toLocaleString()' : f.type === 'boolean' ? " ? 'Yes' : 'No'" : ''}}</dd>
          </div>`)
      .join('\n')

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// ${name} Detail Component
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { Link, useParams, useNavigate } from 'react-router-dom'
import { use${name}, useDelete${name} } from '../hooks/use${name}'

export function ${name}Detail() {
  const { id } = useParams<{ id: string }>()
  const navigate = useNavigate()
  const { data, isLoading, error } = use${name}(id)
  const deleteMutation = useDelete${name}()

  if (isLoading) return <div className="p-4">Loading...</div>
  if (error) return <div className="p-4 text-red-500">Error: {error.message}</div>
  if (!data) return <div className="p-4">Not found</div>

  const handleDelete = async () => {
    if (!confirm('Are you sure you want to delete this ${name.toLowerCase()}?')) return

    try {
      await deleteMutation.mutateAsync(id!)
      navigate('/${plural.toLowerCase()}')
    } catch (error) {
      console.error('Delete error:', error)
    }
  }

  return (
    <div className="p-4 max-w-2xl mx-auto">
      <div className="flex justify-between items-center mb-4">
        <h1 className="text-2xl font-bold">${name} Details</h1>
        <div className="flex gap-2">
          <Link
            to={\`/${plural.toLowerCase()}/\${id}/edit\`}
            className="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600"
          >
            Edit
          </Link>
          <button
            onClick={handleDelete}
            className="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600"
          >
            Delete
          </button>
        </div>
      </div>

      <dl className="grid grid-cols-2 gap-4 bg-white p-4 rounded border">
${fieldDisplay}
      </dl>

      <div className="mt-4">
        <Link
          to="/${plural.toLowerCase()}"
          className="text-blue-500 hover:underline"
        >
          ← Back to list
        </Link>
      </div>
    </div>
  )
}

export default ${name}Detail
`

    return {
      path: `src/pages/${name}Detail.tsx`,
      content,
    }
  }

  generateLayout(spec: TurbineSpec): GeneratedCode {
    const content = `// ═══════════════════════════════════════════════════════════════════════════
// Layout Component
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { Outlet } from 'react-router-dom'
import { Navigation } from './Navigation'

export function Layout() {
  return (
    <div className="min-h-screen bg-gray-50">
      <Navigation />
      <main className="container mx-auto py-4">
        <Outlet />
      </main>
    </div>
  )
}

export default Layout
`

    return {
      path: 'src/components/Layout.tsx',
      content,
    }
  }

  generateNavigation(entities: Entity[]): GeneratedCode {
    const links = entities
      .map((e) => {
        const plural = e.plural ?? e.name + 's'
        return `          <Link to="/${plural.toLowerCase()}" className="hover:text-blue-200">${plural}</Link>`
      })
      .join('\n')

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// Navigation Component
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { Link } from 'react-router-dom'

export function Navigation() {
  return (
    <nav className="bg-blue-600 text-white p-4">
      <div className="container mx-auto flex items-center justify-between">
        <Link to="/" className="text-xl font-bold">Home</Link>
        <div className="flex gap-4">
${links}
        </div>
      </div>
    </nav>
  )
}

export default Navigation
`

    return {
      path: 'src/components/Navigation.tsx',
      content,
    }
  }

  generatePages(entities: Entity[]): GeneratedCode[] {
    const pages: GeneratedCode[] = []

    for (const entity of entities) {
      pages.push(this.generateEntityList(entity))
      pages.push(this.generateEntityForm(entity))
      pages.push(this.generateEntityDetail(entity))
    }

    return pages
  }

  generateApiClient(): GeneratedCode {
    const content = `// ═══════════════════════════════════════════════════════════════════════════
// API Client
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

const API_BASE = import.meta.env.VITE_API_URL ?? 'http://localhost:3000/api'

export class ApiError extends Error {
  constructor(
    public status: number,
    message: string,
    public details?: unknown
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

async function handleResponse<T>(response: Response): Promise<T> {
  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: 'Unknown error' }))
    throw new ApiError(response.status, error.title ?? error.message, error)
  }
  return response.json()
}

export const apiClient = {
  async get<T>(path: string, params?: Record<string, string>): Promise<T> {
    const url = new URL(\`\${API_BASE}\${path}\`)
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value) url.searchParams.set(key, value)
      })
    }

    const response = await fetch(url.toString(), {
      headers: {
        'Content-Type': 'application/json',
        ...this.getAuthHeaders(),
      },
    })
    return handleResponse<T>(response)
  },

  async post<T>(path: string, data: unknown): Promise<T> {
    const response = await fetch(\`\${API_BASE}\${path}\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...this.getAuthHeaders(),
      },
      body: JSON.stringify(data),
    })
    return handleResponse<T>(response)
  },

  async patch<T>(path: string, data: unknown): Promise<T> {
    const response = await fetch(\`\${API_BASE}\${path}\`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        ...this.getAuthHeaders(),
      },
      body: JSON.stringify(data),
    })
    return handleResponse<T>(response)
  },

  async delete(path: string): Promise<void> {
    const response = await fetch(\`\${API_BASE}\${path}\`, {
      method: 'DELETE',
      headers: {
        ...this.getAuthHeaders(),
      },
    })
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: 'Unknown error' }))
      throw new ApiError(response.status, error.title ?? error.message, error)
    }
  },

  getAuthHeaders(): Record<string, string> {
    const token = localStorage.getItem('token')
    return token ? { Authorization: \`Bearer \${token}\` } : {}
  },
}

export default apiClient
`

    return {
      path: 'src/lib/api-client.ts',
      content,
    }
  }

  generateEntityHooks(entity: Entity): GeneratedCode {
    const name = entity.name
    const camelName = name.charAt(0).toLowerCase() + name.slice(1)
    const plural = entity.plural ?? name + 's'

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// ${name} Hooks
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { apiClient } from '../lib/api-client'

export interface ${name} {
  id: string
  // TODO: Add typed fields
  [key: string]: unknown
}

export interface ${name}ListResponse {
  data: ${name}[]
  meta: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

interface ListParams {
  page?: number
  search?: string
}

// List hook
export function use${name}List(params: ListParams = {}) {
  return useQuery({
    queryKey: ['${plural.toLowerCase()}', params],
    queryFn: () =>
      apiClient.get<${name}ListResponse>('/${plural.toLowerCase()}', {
        page: String(params.page ?? 1),
        search: params.search ?? '',
      }),
  })
}

// Single item hook
export function use${name}(id: string | undefined, options?: { enabled?: boolean }) {
  return useQuery({
    queryKey: ['${plural.toLowerCase()}', id],
    queryFn: () => apiClient.get<${name}>(\`/${plural.toLowerCase()}/\${id}\`),
    enabled: !!id && (options?.enabled ?? true),
  })
}

// Create mutation
export function useCreate${name}() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: Omit<${name}, 'id'>) =>
      apiClient.post<${name}>('/${plural.toLowerCase()}', data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['${plural.toLowerCase()}'] })
    },
  })
}

// Update mutation
export function useUpdate${name}() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<${name}> }) =>
      apiClient.patch<${name}>(\`/${plural.toLowerCase()}/\${id}\`, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['${plural.toLowerCase()}'] })
      queryClient.invalidateQueries({ queryKey: ['${plural.toLowerCase()}', id] })
    },
  })
}

// Delete mutation
export function useDelete${name}() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (id: string) => apiClient.delete(\`/${plural.toLowerCase()}/\${id}\`),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['${plural.toLowerCase()}'] })
    },
  })
}
`

    return {
      path: `src/hooks/use${name}.ts`,
      content,
    }
  }

  private toTitleCase(str: string): string {
    return str
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (s) => s.toUpperCase())
      .trim()
  }
}

// Register adapter
adapterRegistry.registerFrontend('react', () => new ReactAdapter())
