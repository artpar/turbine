// ═══════════════════════════════════════════════════════════════════════════
// TURBINE - Prisma ORM Adapter
// ═══════════════════════════════════════════════════════════════════════════
// Generates Prisma schema and repositories from spec

import { ORMAdapter, GeneratedCode, CodeGap, adapterRegistry } from './base.js'
import { Entity, Field, getEntityFields } from '../spec-parser.js'

export class PrismaAdapter implements ORMAdapter {
  name = 'prisma'

  getDependencies(): Record<string, string> {
    return {
      '@prisma/client': '^5.8.0',
    }
  }

  getDevDependencies(): Record<string, string> {
    return {
      prisma: '^5.8.0',
    }
  }

  generateSchema(entities: Entity[]): GeneratedCode {
    const models = entities.map((entity) => this.generateModel(entity)).join('\n\n')

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// Prisma Schema
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

${models}
`

    return {
      path: 'prisma/schema.prisma',
      content,
    }
  }

  private generateModel(entity: Entity): string {
    const fields = getEntityFields(entity)
    const modelFields = fields.map((f) => this.generateField(f, entity)).join('\n')

    // Generate relation fields
    const relationFields = this.generateRelationFields(entity)

    return `model ${entity.name} {
${modelFields}
${relationFields}
  @@map("${entity.tableName ?? entity.name.toLowerCase()}")
}`
  }

  private generateField(field: Field, entity: Entity): string {
    const prismaType = this.fieldToPrismaType(field)
    const attrs = this.fieldAttributes(field)

    // Handle primary key
    if (field.name === 'id') {
      return `  id        String   @id @default(uuid())`
    }

    // Handle timestamps
    if (field.name === 'createdAt') {
      return `  createdAt DateTime @default(now()) @map("created_at")`
    }
    if (field.name === 'updatedAt') {
      return `  updatedAt DateTime @updatedAt @map("updated_at")`
    }
    if (field.name === 'deletedAt') {
      return `  deletedAt DateTime? @map("deleted_at")`
    }

    const optional = !field.validation?.required ? '?' : ''
    const mapName =
      field.name !== this.toSnakeCase(field.name) ? ` @map("${this.toSnakeCase(field.name)}")` : ''

    return `  ${field.name.padEnd(10)} ${prismaType}${optional}${attrs}${mapName}`
  }

  private fieldToPrismaType(field: Field): string {
    switch (field.type) {
      case 'string':
        return 'String'
      case 'text':
        return 'String'
      case 'email':
        return 'String'
      case 'url':
        return 'String'
      case 'number':
        return 'Float'
      case 'integer':
        return 'Int'
      case 'boolean':
        return 'Boolean'
      case 'date':
        return 'DateTime'
      case 'datetime':
        return 'DateTime'
      case 'uuid':
        return 'String'
      case 'json':
        return 'Json'
      case 'enum':
        return `${field.name}Type`
      case 'relation':
        return 'String' // Foreign key stored as string
      default:
        return 'String'
    }
  }

  private fieldAttributes(field: Field): string {
    const attrs: string[] = []

    if (field.validation?.unique) {
      attrs.push('@unique')
    }

    if (field.validation?.default !== undefined) {
      const defaultVal =
        typeof field.validation.default === 'string'
          ? `"${field.validation.default}"`
          : field.validation.default
      attrs.push(`@default(${defaultVal})`)
    }

    return attrs.length > 0 ? ' ' + attrs.join(' ') : ''
  }

  private generateRelationFields(entity: Entity): string {
    const relations = entity.fields.filter((f) => f.type === 'relation' && f.relation)

    return relations
      .map((field) => {
        const rel = field.relation!
        const fieldName = field.name.replace('Id', '')

        switch (rel.type) {
          case 'belongsTo':
            return `  ${fieldName}   ${rel.target}  @relation(fields: [${field.name}], references: [id])
  ${field.name}   String    @map("${this.toSnakeCase(field.name)}")`

          case 'hasMany':
            return `  ${fieldName}   ${rel.target}[]`

          case 'hasOne':
            return `  ${fieldName}   ${rel.target}?`

          default:
            return ''
        }
      })
      .filter(Boolean)
      .join('\n')
  }

  private toSnakeCase(str: string): string {
    return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '')
  }

  generateMigration(_entities: Entity[]): GeneratedCode | null {
    // Prisma generates migrations via CLI
    return null
  }

  generateRepository(entity: Entity): GeneratedCode {
    const fields = getEntityFields(entity)
    const name = entity.name
    const camelName = name.charAt(0).toLowerCase() + name.slice(1)
    const gaps: CodeGap[] = []

    const searchableFields = fields.filter((f) => f.searchable)
    const sortableFields = fields.filter((f) => f.sortable)

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// ${name} Repository
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { PrismaClient, ${name}, Prisma } from '@prisma/client'

export interface ${name}Query {
  page: number
  limit: number
  sort?: string
  order: 'asc' | 'desc'
  search?: string
}

export interface ${name}ListResult {
  data: ${name}[]
  meta: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

export function ${camelName}Repository(prisma: PrismaClient) {
  return {
    async findById(id: string): Promise<${name} | null> {
      return prisma.${camelName}.findUnique({
        where: { id${entity.softDelete ? ', deletedAt: null' : ''} },
      })
    },

    async findMany(query: ${name}Query): Promise<${name}ListResult> {
      const { page, limit, sort, order, search } = query
      const skip = (page - 1) * limit

      const where: Prisma.${name}WhereInput = {
        ${entity.softDelete ? 'deletedAt: null,' : ''}
        ${
          searchableFields.length > 0
            ? `...(search ? {
          OR: [
            ${searchableFields.map((f) => `{ ${f.name}: { contains: search, mode: 'insensitive' } },`).join('\n            ')}
          ],
        } : {}),`
            : ''
        }
      }

      const orderBy: Prisma.${name}OrderByWithRelationInput = sort
        ? { [sort]: order }
        : { createdAt: order }

      const [data, total] = await Promise.all([
        prisma.${camelName}.findMany({
          where,
          orderBy,
          skip,
          take: limit,
        }),
        prisma.${camelName}.count({ where }),
      ])

      return {
        data,
        meta: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      }
    },

    async create(input: Prisma.${name}CreateInput): Promise<${name}> {
      // TODO: Add pre-create business logic
      return prisma.${camelName}.create({ data: input })
    },

    async update(id: string, input: Prisma.${name}UpdateInput): Promise<${name}> {
      // TODO: Add pre-update business logic
      return prisma.${camelName}.update({
        where: { id },
        data: input,
      })
    },

    ${
      entity.softDelete
        ? `async softDelete(id: string): Promise<${name}> {
      return prisma.${camelName}.update({
        where: { id },
        data: { deletedAt: new Date() },
      })
    },`
        : ''
    }

    async delete(id: string): Promise<${name}> {
      return prisma.${camelName}.delete({ where: { id } })
    },

    async count(where?: Prisma.${name}WhereInput): Promise<number> {
      return prisma.${camelName}.count({ where })
    },
  }
}

export type ${name}Repository = ReturnType<typeof ${camelName}Repository>
`

    return {
      path: `src/repositories/${camelName}.repository.ts`,
      content,
      gaps,
    }
  }

  generateRepositoryIndex(entities: Entity[]): GeneratedCode {
    const imports = entities
      .map((e) => {
        const camelName = e.name.charAt(0).toLowerCase() + e.name.slice(1)
        return `export { ${camelName}Repository, type ${e.name}Repository } from './${camelName}.repository.js'`
      })
      .join('\n')

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// Repository Index
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

${imports}
`

    return {
      path: 'src/repositories/index.ts',
      content,
    }
  }

  generateClientSetup(): GeneratedCode {
    const content = `// ═══════════════════════════════════════════════════════════════════════════
// Prisma Client Setup
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { PrismaClient } from '@prisma/client'
import { FastifyPluginAsync } from 'fastify'
import fp from 'fastify-plugin'

// Singleton pattern for Prisma Client
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development'
      ? ['query', 'error', 'warn']
      : ['error'],
  })

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}

// Fastify plugin
declare module 'fastify' {
  interface FastifyInstance {
    db: PrismaClient
  }
}

export const dbPlugin: FastifyPluginAsync = fp(async (fastify) => {
  fastify.decorate('db', prisma)

  fastify.addHook('onClose', async () => {
    await prisma.$disconnect()
  })
})

export { PrismaClient }
`

    return {
      path: 'src/db/client.ts',
      content,
    }
  }
}

// Register adapter
adapterRegistry.registerORM('prisma', () => new PrismaAdapter())
