// ═══════════════════════════════════════════════════════════════════════════
// TURBINE - Fastify Backend Adapter
// ═══════════════════════════════════════════════════════════════════════════
// Generates Fastify server code from spec

import { BackendAdapter, GeneratedCode, CodeGap, adapterRegistry } from './base.js'
import { Entity, TurbineSpec, getEntityFields, fieldTypeToZod, Field } from '../spec-parser.js'

export class FastifyAdapter implements BackendAdapter {
  name = 'fastify'

  getDependencies(): Record<string, string> {
    return {
      fastify: '^4.26.0',
      '@fastify/cors': '^9.0.0',
      '@fastify/helmet': '^11.0.0',
      '@fastify/rate-limit': '^9.0.0',
      '@fastify/swagger': '^8.0.0',
      '@fastify/swagger-ui': '^2.0.0',
      '@fastify/sensible': '^5.0.0',
      zod: '^3.22.0',
    }
  }

  getDevDependencies(): Record<string, string> {
    return {
      '@types/node': '^20.0.0',
      typescript: '^5.3.0',
    }
  }

  generateRoute(entity: Entity): GeneratedCode {
    const fields = getEntityFields(entity)
    const name = entity.name
    const plural = entity.plural ?? name + 's'
    const camelName = name.charAt(0).toLowerCase() + name.slice(1)
    const pascalName = name.charAt(0).toUpperCase() + name.slice(1)

    const gaps: CodeGap[] = []
    let gapLine = 0

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// ${pascalName} Routes
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine - Modify business logic in marked sections

import { FastifyPluginAsync } from 'fastify'
import { z } from 'zod'
import { ${camelName}Repository } from '../repositories/${camelName}.repository.js'

// ═══════════════════════════════════════════════════════════════════════════
// SCHEMAS
// ═══════════════════════════════════════════════════════════════════════════

${this.generateSchemas(entity, fields)}

// ═══════════════════════════════════════════════════════════════════════════
// ROUTES
// ═══════════════════════════════════════════════════════════════════════════

export const ${camelName}Routes: FastifyPluginAsync = async (fastify) => {
  const repo = ${camelName}Repository(fastify.db)

${entity.operations.includes('list') ? this.generateListRoute(entity, camelName, plural) : ''}
${entity.operations.includes('read') ? this.generateReadRoute(entity, camelName, plural) : ''}
${entity.operations.includes('create') ? this.generateCreateRoute(entity, camelName, plural, gaps) : ''}
${entity.operations.includes('update') ? this.generateUpdateRoute(entity, camelName, plural, gaps) : ''}
${entity.operations.includes('delete') ? this.generateDeleteRoute(entity, camelName, plural) : ''}
}

export default ${camelName}Routes
`

    return {
      path: `src/routes/${camelName}.routes.ts`,
      content,
      gaps,
    }
  }

  private generateSchemas(entity: Entity, fields: Field[]): string {
    const createFields = fields
      .filter((f) => !['id', 'createdAt', 'updatedAt', 'deletedAt'].includes(f.name))
      .map((f) => `  ${f.name}: ${fieldTypeToZod(f)},`)
      .join('\n')

    const updateFields = fields
      .filter((f) => !['id', 'createdAt', 'updatedAt', 'deletedAt'].includes(f.name))
      .map((f) => `  ${f.name}: ${fieldTypeToZod(f)}.optional(),`)
      .join('\n')

    return `const Create${entity.name}Schema = z.object({
${createFields}
})

const Update${entity.name}Schema = z.object({
${updateFields}
})

const ${entity.name}ParamsSchema = z.object({
  id: z.string().uuid(),
})

const ${entity.name}QuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().max(100).default(20),
  sort: z.string().optional(),
  order: z.enum(['asc', 'desc']).default('desc'),
  search: z.string().optional(),
})

export type Create${entity.name}Input = z.infer<typeof Create${entity.name}Schema>
export type Update${entity.name}Input = z.infer<typeof Update${entity.name}Schema>
`
  }

  private generateListRoute(entity: Entity, camelName: string, plural: string): string {
    return `  // GET /${plural} - List all ${plural}
  fastify.get('/${plural}', {
    schema: {
      querystring: ${entity.name}QuerySchema,
      response: {
        200: z.object({
          data: z.array(z.unknown()),
          meta: z.object({
            page: z.number(),
            limit: z.number(),
            total: z.number(),
            totalPages: z.number(),
          }),
        }),
      },
    },
  }, async (request, reply) => {
    const query = ${entity.name}QuerySchema.parse(request.query)
    const result = await repo.findMany(query)
    return result
  })

`
  }

  private generateReadRoute(entity: Entity, camelName: string, plural: string): string {
    return `  // GET /${plural}/:id - Get single ${camelName}
  fastify.get('/${plural}/:id', {
    schema: {
      params: ${entity.name}ParamsSchema,
    },
  }, async (request, reply) => {
    const { id } = ${entity.name}ParamsSchema.parse(request.params)
    const ${camelName} = await repo.findById(id)

    if (!${camelName}) {
      return reply.notFound(\`${entity.name} not found: \${id}\`)
    }

    return ${camelName}
  })

`
  }

  private generateCreateRoute(
    entity: Entity,
    camelName: string,
    plural: string,
    gaps: CodeGap[]
  ): string {
    gaps.push({
      type: 'business-logic',
      location: { line: 0, placeholder: '// TODO: Add business logic before create' },
      context: `Pre-create hook for ${entity.name}`,
      hint: 'Add validation, transformation, or side effects before creating',
    })

    return `  // POST /${plural} - Create ${camelName}
  fastify.post('/${plural}', {
    schema: {
      body: Create${entity.name}Schema,
    },
  }, async (request, reply) => {
    const input = Create${entity.name}Schema.parse(request.body)

    // TODO: Add business logic before create

    const ${camelName} = await repo.create(input)

    // TODO: Add business logic after create (notifications, etc.)

    return reply.status(201).send(${camelName})
  })

`
  }

  private generateUpdateRoute(
    entity: Entity,
    camelName: string,
    plural: string,
    gaps: CodeGap[]
  ): string {
    gaps.push({
      type: 'business-logic',
      location: { line: 0, placeholder: '// TODO: Add business logic before update' },
      context: `Pre-update hook for ${entity.name}`,
      hint: 'Add validation or authorization checks before updating',
    })

    return `  // PATCH /${plural}/:id - Update ${camelName}
  fastify.patch('/${plural}/:id', {
    schema: {
      params: ${entity.name}ParamsSchema,
      body: Update${entity.name}Schema,
    },
  }, async (request, reply) => {
    const { id } = ${entity.name}ParamsSchema.parse(request.params)
    const input = Update${entity.name}Schema.parse(request.body)

    const existing = await repo.findById(id)
    if (!existing) {
      return reply.notFound(\`${entity.name} not found: \${id}\`)
    }

    // TODO: Add business logic before update

    const ${camelName} = await repo.update(id, input)
    return ${camelName}
  })

`
  }

  private generateDeleteRoute(entity: Entity, camelName: string, plural: string): string {
    const deleteMethod = entity.softDelete ? 'softDelete' : 'delete'

    return `  // DELETE /${plural}/:id - Delete ${camelName}
  fastify.delete('/${plural}/:id', {
    schema: {
      params: ${entity.name}ParamsSchema,
    },
  }, async (request, reply) => {
    const { id } = ${entity.name}ParamsSchema.parse(request.params)

    const existing = await repo.findById(id)
    if (!existing) {
      return reply.notFound(\`${entity.name} not found: \${id}\`)
    }

    await repo.${deleteMethod}(id)
    return reply.status(204).send()
  })

`
  }

  generateRouteIndex(entities: Entity[]): GeneratedCode {
    const imports = entities
      .map((e) => {
        const camelName = e.name.charAt(0).toLowerCase() + e.name.slice(1)
        return `import ${camelName}Routes from './${camelName}.routes.js'`
      })
      .join('\n')

    const registers = entities
      .map((e) => {
        const camelName = e.name.charAt(0).toLowerCase() + e.name.slice(1)
        return `  fastify.register(${camelName}Routes, { prefix: '/api' })`
      })
      .join('\n')

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// Route Index
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { FastifyPluginAsync } from 'fastify'

${imports}

export const routes: FastifyPluginAsync = async (fastify) => {
${registers}
}

export default routes
`

    return {
      path: 'src/routes/index.ts',
      content,
    }
  }

  generateAuthMiddleware(): GeneratedCode {
    return {
      path: 'src/middleware/auth.ts',
      content: `// ═══════════════════════════════════════════════════════════════════════════
// Auth Middleware
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { FastifyRequest, FastifyReply } from 'fastify'
import { verifyToken } from '../utils/jwt.js'

export async function authMiddleware(
  request: FastifyRequest,
  reply: FastifyReply
) {
  const authHeader = request.headers.authorization

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return reply.unauthorized('Missing or invalid authorization header')
  }

  const token = authHeader.slice(7)

  try {
    const payload = await verifyToken(token)
    request.user = payload
  } catch (error) {
    return reply.unauthorized('Invalid or expired token')
  }
}

// Extend FastifyRequest to include user
declare module 'fastify' {
  interface FastifyRequest {
    user?: {
      id: string
      email: string
      role: string
    }
  }
}
`,
    }
  }

  generateErrorHandler(): GeneratedCode {
    return {
      path: 'src/middleware/error-handler.ts',
      content: `// ═══════════════════════════════════════════════════════════════════════════
// Error Handler
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine - RFC 9457 Problem Details

import { FastifyError, FastifyReply, FastifyRequest } from 'fastify'
import { ZodError } from 'zod'

interface ProblemDetails {
  type: string
  title: string
  status: number
  detail?: string
  instance?: string
  errors?: Array<{ path: string; message: string }>
}

export function errorHandler(
  error: FastifyError,
  request: FastifyRequest,
  reply: FastifyReply
) {
  request.log.error(error)

  // Zod validation errors
  if (error instanceof ZodError) {
    const problem: ProblemDetails = {
      type: 'https://httpstatuses.com/400',
      title: 'Validation Error',
      status: 400,
      detail: 'Request validation failed',
      instance: request.url,
      errors: error.errors.map((e) => ({
        path: e.path.join('.'),
        message: e.message,
      })),
    }
    return reply.status(400).send(problem)
  }

  // Known HTTP errors (from @fastify/sensible)
  if (error.statusCode) {
    const problem: ProblemDetails = {
      type: \`https://httpstatuses.com/\${error.statusCode}\`,
      title: error.message,
      status: error.statusCode,
      instance: request.url,
    }
    return reply.status(error.statusCode).send(problem)
  }

  // Unknown errors
  const problem: ProblemDetails = {
    type: 'https://httpstatuses.com/500',
    title: 'Internal Server Error',
    status: 500,
    detail: process.env.NODE_ENV === 'development' ? error.message : undefined,
    instance: request.url,
  }
  return reply.status(500).send(problem)
}
`,
    }
  }

  generateValidationMiddleware(): GeneratedCode {
    return {
      path: 'src/middleware/validation.ts',
      content: `// ═══════════════════════════════════════════════════════════════════════════
// Validation Middleware
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import { FastifyPluginAsync } from 'fastify'
import fp from 'fastify-plugin'
import { z, ZodType } from 'zod'

declare module 'fastify' {
  interface FastifyRequest {
    validatedBody: unknown
    validatedParams: unknown
    validatedQuery: unknown
  }
}

export interface ValidationOptions {
  body?: ZodType
  params?: ZodType
  query?: ZodType
}

export const validationPlugin: FastifyPluginAsync = fp(async (fastify) => {
  fastify.addHook('preValidation', async (request, reply) => {
    const schema = (request.routeOptions.schema as ValidationOptions) ?? {}

    if (schema.body) {
      request.validatedBody = schema.body.parse(request.body)
    }

    if (schema.params) {
      request.validatedParams = schema.params.parse(request.params)
    }

    if (schema.query) {
      request.validatedQuery = schema.query.parse(request.query)
    }
  })
})

export default validationPlugin
`,
    }
  }

  generateServerSetup(spec: TurbineSpec): GeneratedCode {
    const plugins: string[] = []

    if (spec.features.cors) {
      plugins.push(`  await fastify.register(cors, { origin: true })`)
    }

    if (spec.features.rateLimit) {
      plugins.push(`  await fastify.register(rateLimit, { max: 100, timeWindow: '1 minute' })`)
    }

    if (spec.features.openapi) {
      plugins.push(`  await fastify.register(swagger, {
    openapi: {
      info: {
        title: '${spec.project.name} API',
        description: '${spec.project.description}',
        version: '${spec.project.version}',
      },
    },
  })
  await fastify.register(swaggerUi, { routePrefix: '/docs' })`)
    }

    if (spec.features.healthCheck) {
      plugins.push(`  fastify.get('/health', async () => ({ status: 'ok', timestamp: new Date().toISOString() }))`)
    }

    const content = `// ═══════════════════════════════════════════════════════════════════════════
// Server Setup
// ═══════════════════════════════════════════════════════════════════════════
// Auto-generated by Turbine

import Fastify from 'fastify'
import cors from '@fastify/cors'
import helmet from '@fastify/helmet'
import rateLimit from '@fastify/rate-limit'
import sensible from '@fastify/sensible'
import swagger from '@fastify/swagger'
import swaggerUi from '@fastify/swagger-ui'
import { errorHandler } from './middleware/error-handler.js'
import routes from './routes/index.js'
import { dbPlugin } from './db/client.js'

export async function buildServer() {
  const fastify = Fastify({
    logger: {
      level: process.env.LOG_LEVEL ?? 'info',
      transport: process.env.NODE_ENV === 'development'
        ? { target: 'pino-pretty' }
        : undefined,
    },
  })

  // Error handling
  fastify.setErrorHandler(errorHandler)

  // Security
  await fastify.register(helmet)
  await fastify.register(sensible)

  // Plugins
${plugins.join('\n\n')}

  // Database
  await fastify.register(dbPlugin)

  // Routes
  await fastify.register(routes)

  return fastify
}

// Start server
async function start() {
  const server = await buildServer()

  try {
    const port = parseInt(process.env.PORT ?? '3000', 10)
    const host = process.env.HOST ?? '0.0.0.0'

    await server.listen({ port, host })
    console.log(\`Server listening on http://\${host}:\${port}\`)
  } catch (err) {
    server.log.error(err)
    process.exit(1)
  }
}

start()
`

    return {
      path: 'src/server.ts',
      content,
    }
  }

  generatePlugins(spec: TurbineSpec): GeneratedCode[] {
    return []
  }
}

// Register adapter
adapterRegistry.registerBackend('fastify', () => new FastifyAdapter())
